name: Deploy Bedrock Chat Multi-Repo
on:
  workflow_run:
    workflows: ["Setup Infra and Deploy GitHub Runner"]
    types:
      - completed
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout main repo
      uses: actions/checkout@v4
      with:
        path: main-repo
    
    - name: Run setup script
      run: |
        echo "Running setup.sh from main repo root..."
        cd main-repo
        if [ -f "setup.sh" ]; then
          chmod +x setup.sh
          ./setup.sh
          echo "Setup script executed successfully"
        else
          echo "ERROR: setup.sh not found in main repo root"
          exit 1
        fi
    
    - name: Checkout front-end repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/front-end
        path: front-end
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout bedrock-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/bedrock-service
        path: bedrock-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout file-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/file-service
        path: file-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout api-gateway repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/api-gateway
        path: api-gateway
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup and Verify Ingress Controller
      run: |
        echo "Setting up NGINX Ingress Controller..."
        
        # Check if ingress-nginx namespace exists, if not create it
        if ! kubectl get namespace ingress-nginx >/dev/null 2>&1; then
          echo "Creating ingress-nginx namespace..."
          kubectl create namespace ingress-nginx
        fi
        
        # Apply NGINX Ingress Controller (idempotent operation)
        echo "Applying NGINX Ingress Controller manifests..."
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
        
        # Wait for ingress controller deployment to be available
        echo "Waiting for ingress controller deployment..."
        kubectl wait --namespace ingress-nginx \
          --for=condition=available \
          deployment/ingress-nginx-controller \
          --timeout=300s
        
        echo "Verifying ingress controller pods..."
        kubectl get pods -n ingress-nginx
        
        # Wait for all ingress controller pods to be ready
        echo "Waiting for ingress controller pods to be ready..."
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=300s
        
        # Check if admission webhook is ready
        echo "Checking admission webhook readiness..."
        for i in {1..30}; do
          if kubectl get validatingwebhookconfiguration ingress-nginx-admission >/dev/null 2>&1; then
            echo "Admission webhook is ready"
            break
          fi
          echo "Attempt $i/30: Waiting for admission webhook... (10s)"
          sleep 10
          if [ $i -eq 30 ]; then
            echo "WARNING: Admission webhook not ready after 5 minutes, continuing anyway..."
          fi
        done
        
        # Verify service is running
        echo "Verifying ingress controller service..."
        kubectl get service ingress-nginx-controller -n ingress-nginx
        
        echo "Ingress controller setup completed successfully"

    - name: Deploy Main Repo Infrastructure
      run: |
        echo "Deploying main repo Kubernetes manifests..."
        cd main-repo
        kubectl apply -f namespace.yaml
        kubectl apply -f secrets/
        kubectl apply -f configmaps/
        kubectl apply -f metrics-server-custom.yaml
        kubectl apply -f statefulsets/
        kubectl apply -f services/
        kubectl apply -f monitoring/
        kubectl apply -f network-policies/
        kubectl apply -f hpa/
        
        echo "Main infrastructure deployed successfully"
    
    - name: Create AWS Secrets
      run: |
        echo "Creating AWS secrets..."
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Secret
        metadata:
          name: app-secrets
          namespace: bedrock-chat-v2
        type: Opaque
        stringData:
          AWS_ACCESS_KEY_ID: "${{ secrets.AWS_ACCESS_KEY_ID }}"
          AWS_SECRET_ACCESS_KEY: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          AWS_REGION: "us-east-1"
        EOF
        echo "AWS secrets created"
    
    - name: Deploy Front-End Service
      run: |
        echo "Deploying front-end Kubernetes manifests..."
        if [ -d "front-end/k8s" ]; then
          kubectl apply -f front-end/k8s/ --recursive
        else
          echo "No k8s folder found in front-end repo"
        fi
    
    - name: Deploy Bedrock Service
      run: |
        echo "Deploying bedrock-service Kubernetes manifests..."
        if [ -d "bedrock-service/k8s" ]; then
          kubectl apply -f bedrock-service/k8s/ --recursive
        else
          echo "No k8s folder found in bedrock-service repo"
        fi
    
    - name: Deploy File Service
      run: |
        echo "Deploying file-service Kubernetes manifests..."
        if [ -d "file-service/k8s" ]; then
          kubectl apply -f file-service/k8s/ --recursive
        else
          echo "No k8s folder found in file-service repo"
        fi
    
    - name: Deploy API Gateway
      run: |
        echo "Deploying api-gateway Kubernetes manifests..."
        if [ -d "api-gateway/k8s" ]; then
          kubectl apply -f api-gateway/k8s/ --recursive
        else
          echo "No k8s folder found in api-gateway repo"
        fi
    
    - name: Deploy Ingress Rules
      run: |
        echo "Deploying ingress rules with enhanced retry logic..."
        cd main-repo
        
        # Wait additional time for ingress controller to be fully stable
        echo "Additional stabilization wait for ingress controller..."
        sleep 30
        
        # Deploy ingress with comprehensive retry logic
        for attempt in {1..5}; do
          echo "Ingress deployment attempt $attempt/5"
          
          if kubectl apply -f ingress/; then
            echo "Ingress rules applied successfully"
            
            # Verify ingress was created properly
            echo "Verifying ingress resources..."
            kubectl get ingress -n bedrock-chat-v2
            
            # Check ingress status
            if kubectl get ingress bedrock-chat-ingress -n bedrock-chat-v2 >/dev/null 2>&1; then
              echo "Ingress created successfully"
              break
            else
              echo "Ingress not found after creation, retrying..."
            fi
          else
            echo "Ingress deployment failed on attempt $attempt"
          fi
          
          if [ $attempt -lt 5 ]; then
            echo "Waiting 45s before retry..."
            sleep 45
          else
            echo "ERROR: Failed to deploy ingress after 5 attempts"
            exit 1
          fi
        done
        
        echo "Ingress deployment completed"
    
    - name: Wait for Application Components
      run: |
        echo "Waiting for application components to be ready..."
        
        echo "Waiting for MySQL..."
        kubectl wait --for=condition=ready pod -l app=mysql -n bedrock-chat-v2 --timeout=600s || echo "MySQL timeout, continuing..."
        
        echo "Waiting for application services..."
        kubectl wait --for=condition=ready pod -l app=frontend -n bedrock-chat-v2 --timeout=300s || echo "Frontend timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=api-gateway -n bedrock-chat-v2 --timeout=300s || echo "API Gateway timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=bedrock-service -n bedrock-chat-v2 --timeout=300s || echo "Bedrock Service timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=file-service -n bedrock-chat-v2 --timeout=300s || echo "File Service timeout, continuing..."
        
        echo "Current pod status:"
        kubectl get pods -n bedrock-chat-v2
        
        echo "Additional stabilization time (60s)..."
        sleep 60
    
    - name: Determine Application URL
      id: app_url
      run: |
        echo "Determining application access URL..."
        
        APP_URL=""
        ACCESS_METHOD=""
        
        INGRESS_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -n "$INGRESS_IP" ] && [ "$INGRESS_IP" != "null" ]; then
          APP_URL="http://$INGRESS_IP"
          ACCESS_METHOD="ingress-loadbalancer"
        fi
        
        if [ -z "$APP_URL" ]; then
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null)
          fi
          NODE_PORT=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}' 2>/dev/null)
          
          if [ -n "$NODE_IP" ] && [ -n "$NODE_PORT" ]; then
            APP_URL="http://$NODE_IP:$NODE_PORT"
            ACCESS_METHOD="ingress-nodeport"
          fi
        fi
        
        if [ -z "$APP_URL" ]; then
          FRONTEND_NODEPORT=$(kubectl get svc frontend -n bedrock-chat-v2 -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          if [ -n "$FRONTEND_NODEPORT" ] && [ -n "$NODE_IP" ]; then
            APP_URL="http://$NODE_IP:$FRONTEND_NODEPORT"
            ACCESS_METHOD="direct-service"
          fi
        fi
        
        if [ -z "$APP_URL" ]; then
          APP_URL="http://localhost:80"
          ACCESS_METHOD="localhost-fallback"
        fi
        
        echo "APPLICATION_URL=$APP_URL" >> $GITHUB_OUTPUT
        echo "ACCESS_METHOD=$ACCESS_METHOD" >> $GITHUB_OUTPUT
        echo "Application URL: $APP_URL (method: $ACCESS_METHOD)"
        
        if timeout 10 curl -f -s "$APP_URL" >/dev/null 2>&1; then
          echo "URL is accessible"
          echo "URL_ACCESSIBLE=true" >> $GITHUB_OUTPUT
        else
          echo "URL not immediately accessible (will retry during DAST)"
          echo "URL_ACCESSIBLE=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Setup DAST Environment
      run: |
        echo "Setting up DAST environment..."
        
        sudo systemctl start docker
        sudo usermod -aG docker $USER || true
        
        echo "Pulling OWASP ZAP Docker image..."
        sudo docker pull ghcr.io/zaproxy/zaproxy:stable || echo "Failed to pull ZAP image"
        
        mkdir -p dast-reports
        chmod 777 dast-reports
        
        echo "DAST environment setup completed"
    
    - name: Run DAST Security Scan
      run: |
        echo "Starting DAST security scan..."
        
        APP_URL="${{ steps.app_url.outputs.APPLICATION_URL }}"
        ACCESS_METHOD="${{ steps.app_url.outputs.ACCESS_METHOD }}"
        URL_ACCESSIBLE="${{ steps.app_url.outputs.URL_ACCESSIBLE }}"
        
        echo "Scan Configuration:"
        echo "  Target URL: $APP_URL"
        echo "  Access Method: $ACCESS_METHOD"
        echo "  Initially Accessible: $URL_ACCESSIBLE"
        
        echo "Extended URL accessibility test..."
        RETRIES=8
        WAIT_TIME=30
        FINAL_ACCESSIBLE=false
        
        for i in $(seq 1 $RETRIES); do
          echo "  Attempt $i/$RETRIES: Testing $APP_URL"
          if timeout 15 curl -f -s -L "$APP_URL" >/dev/null 2>&1; then
            echo "  URL accessible on attempt $i"
            FINAL_ACCESSIBLE=true
            break
          else
            echo "  Not accessible, waiting ${WAIT_TIME}s..."
            sleep $WAIT_TIME
          fi
        done
        
        cat > dast-reports/scan-info.txt << 'EOF'
        DAST Security Scan Information
        ==============================
        EOF
        echo "Scan Date: $(date)" >> dast-reports/scan-info.txt
        echo "Target URL: $APP_URL" >> dast-reports/scan-info.txt
        echo "Access Method: $ACCESS_METHOD" >> dast-reports/scan-info.txt
        echo "Final Accessibility: $FINAL_ACCESSIBLE" >> dast-reports/scan-info.txt
        echo "Scanner: OWASP ZAP" >> dast-reports/scan-info.txt
        echo "" >> dast-reports/scan-info.txt
        echo "Scan Results:" >> dast-reports/scan-info.txt
        
        echo "Running OWASP ZAP baseline scan..."
        ZAP_EXIT_CODE=0
        
        sudo docker run --rm -v $(pwd)/dast-reports:/zap/wrk/:rw -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py -t "$APP_URL" -r baseline-report.html -w baseline-report.md -J baseline-report.json -d || ZAP_EXIT_CODE=$?
        
        echo "ZAP baseline scan exit code: $ZAP_EXIT_CODE"
        echo "ZAP Exit Code: $ZAP_EXIT_CODE" >> dast-reports/scan-info.txt
        
        if [ ! -f "dast-reports/baseline-report.html" ] && [ "$FINAL_ACCESSIBLE" = "true" ]; then
          echo "Baseline scan failed, trying API scan..."
          sudo docker run --rm -v $(pwd)/dast-reports:/zap/wrk/:rw -t ghcr.io/zaproxy/zaproxy:stable zap-api-scan.py -t "$APP_URL" -r api-scan-report.html -w api-scan-report.md || echo "API scan also completed with warnings"
        fi
        
        if [ ! -f "dast-reports/baseline-report.html" ] && [ ! -f "dast-reports/api-scan-report.html" ]; then
          echo "Creating fallback security report..."
          cat > dast-reports/fallback-report.html << 'EOF'
        <!DOCTYPE html>
        <html>
        <head><title>DAST Scan Report</title></head>
        <body>
        <h1>DAST Security Scan Report</h1>
        <h2>Scan Status</h2>
        <p><strong>Status:</strong> Scan attempted but application may not have been fully accessible.</p>
        <p><strong>Recommendation:</strong> Verify application deployment and rerun security scan.</p>
        <h2>Next Steps</h2>
        <ul>
        <li>Check application logs for deployment issues</li>
        <li>Verify ingress configuration</li>
        <li>Manually test application accessibility</li>
        <li>Re-run DAST scan when application is confirmed accessible</li>
        </ul>
        </body>
        </html>
        EOF
          echo "Fallback report created" >> dast-reports/scan-info.txt
        fi
        
        echo "DAST scan process completed"
    
    - name: Process DAST Results
      run: |
        echo "Processing DAST scan results..."
        
        echo "Generated files:"
        ls -la dast-reports/ || echo "No files generated"
        
        REPORTS_FOUND=0
        
        if [ -f "dast-reports/baseline-report.html" ]; then
          echo "Baseline HTML report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        if [ -f "dast-reports/baseline-report.md" ]; then
          echo "Baseline Markdown report found"
          echo "Baseline scan summary:"
          head -20 "dast-reports/baseline-report.md" || echo "Could not read markdown report"
        fi
        
        if [ -f "dast-reports/api-scan-report.html" ]; then
          echo "API scan HTML report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        if [ -f "dast-reports/fallback-report.html" ]; then
          echo "Fallback report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        echo "Security analysis:"
        if [ $REPORTS_FOUND -gt 0 ]; then
          if grep -i "high\|critical" dast-reports/*.html dast-reports/*.md 2>/dev/null | head -5; then
            echo "Potential high-risk security issues detected!"
            echo "Review the detailed reports for more information."
          else
            echo "No critical security issues detected in scan."
          fi
        else
          echo "No security reports generated - application may not have been accessible."
        fi
        
        echo "" >> dast-reports/scan-info.txt
        echo "Reports Generated: $REPORTS_FOUND" >> dast-reports/scan-info.txt
        echo "Scan Completed: $(date)" >> dast-reports/scan-info.txt
    
    - name: Upload DAST Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: dast-security-reports-${{ github.run_number }}
        path: dast-reports/
        retention-days: 30
    
    - name: Final Status Check
      run: |
        echo "Deployment completed for all services!"
        
        echo "Current status:"
        kubectl get all -n bedrock-chat-v2
        
        echo "Checking pods status:"
        kubectl get pods -n bedrock-chat-v2 -o wide
        
        echo "Checking services:"
        kubectl get services -n bedrock-chat-v2
        
        echo "Checking ingress:"
        kubectl get ingress -n bedrock-chat-v2
        kubectl describe ingress bedrock-chat-ingress -n bedrock-chat-v2 || echo "Ingress not found"
        
        echo "DAST Security Scan Summary:"
        echo "================================"
        if [ -f "dast-reports/scan-info.txt" ]; then
          cat dast-reports/scan-info.txt
        else
          echo "DAST scan info not available"
        fi
        
        echo ""
        echo "Pipeline completed successfully!"
        echo "Security reports uploaded as artifacts"
        echo "Application URL: ${{ steps.app_url.outputs.APPLICATION_URL }}"
