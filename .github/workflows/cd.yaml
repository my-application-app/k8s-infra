name: Bedrock Chat - Continuous Deployment

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: 'false'

env:
  NAMESPACE: bedrock-chat-v2
  KUBECONFIG: ${{ secrets.KUBECONFIG_PATH || '/home/ubuntu/.kube/config' }}

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify kubectl installation
      run: |
        if ! command -v kubectl &> /dev/null; then
          echo "kubectl not found, installing..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        fi
        kubectl version --client
    
    - name: Verify cluster connectivity
      run: |
        echo "Testing cluster connectivity..."
        kubectl cluster-info
        kubectl get nodes
    
    - name: Create namespace
      run: |
        echo "Creating namespace..."
        kubectl apply -f namespace.yaml
        kubectl get namespace $NAMESPACE
    
    - name: Wait for namespace to be ready
      run: |
        echo "Waiting for namespace to be active..."
        kubectl wait --for=condition=Active namespace/$NAMESPACE --timeout=60s
    
    - name: Apply secrets
      run: |
        echo "Applying secrets..."
        kubectl apply -f secrets/mysql-secrets.yaml
        kubectl apply -f dockerhub-secrets.yaml
        echo "Verifying secrets..."
        kubectl get secrets -n $NAMESPACE
    
    - name: Apply ConfigMaps
      run: |
        echo "Applying ConfigMaps..."
        kubectl apply -f configmaps/app-config.yaml
        kubectl apply -f configmaps/mysql-init.yaml
        echo "Verifying ConfigMaps..."
        kubectl get configmaps -n $NAMESPACE
    
    - name: Apply PersistentVolumeClaims
      run: |
        echo "Applying PVCs..."
        kubectl apply -f monitoring/mysql-backup-cronjob.yaml
        echo "Waiting for PVCs to be bound..."
        kubectl wait --for=condition=Bound pvc/backup-pvc -n $NAMESPACE --timeout=300s || true
        kubectl get pvc -n $NAMESPACE
    
    - name: Fix metrics server (if needed)
      run: |
        echo "Checking metrics server status..."
        if ! kubectl top nodes &>/dev/null; then
          echo "Metrics server not working, applying fix..."
          kubectl apply -f metrics-server-custom.yaml
          echo "Waiting for metrics server to be ready..."
          kubectl rollout status deployment/metrics-server -n kube-system --timeout=300s
        else
          echo "Metrics server is working fine"
        fi
    
    - name: Deploy MySQL StatefulSet
      run: |
        echo "Deploying MySQL StatefulSet..."
        
        # Create directory for MySQL data on the node
        sudo mkdir -p /tmp/mysql-data
        sudo chmod 755 /tmp/mysql-data
        
        kubectl apply -f statefulsets/mysql-statefulset.yaml
        
        echo "Waiting for MySQL StatefulSet to be ready..."
        kubectl rollout status statefulset/mysql -n $NAMESPACE --timeout=600s
        
        echo "Verifying MySQL StatefulSet..."
        kubectl get statefulset/mysql -n $NAMESPACE
        kubectl get pods -l app=mysql -n $NAMESPACE
    
    - name: Deploy MySQL Services
      run: |
        echo "Deploying MySQL services..."
        kubectl apply -f services/mysql-service.yaml
        kubectl apply -f services/mysql-headless-service.yaml
        
        echo "Verifying MySQL services..."
        kubectl get services -l app=mysql -n $NAMESPACE
    
    - name: Wait for MySQL to be fully ready
      run: |
        echo "Waiting for MySQL to be fully ready..."
        # Wait with a more reasonable timeout and better error handling
        kubectl wait --for=condition=Ready pod -l app=mysql -n $NAMESPACE --timeout=300s || echo "MySQL pod not ready yet, checking status..."
        
        echo "Current MySQL pod status:"
        kubectl get pods -l app=mysql -n $NAMESPACE
        
        echo "Testing MySQL connectivity..."
        MYSQL_POD=$(kubectl get pods -l app=mysql -n $NAMESPACE -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        if [ ! -z "$MYSQL_POD" ]; then
          # Try multiple times with backoff
          for i in {1..5}; do
            echo "MySQL connection attempt $i/5..."
            if kubectl exec -n $NAMESPACE $MYSQL_POD -- mysql -u root -proot_password -e "SELECT 1;" 2>/dev/null; then
              echo "✅ MySQL is ready and accepting connections"
              break
            else
              echo "MySQL not ready yet, waiting 30 seconds..."
              sleep 30
            fi
          done
        else
          echo "⚠️  Could not find MySQL pod"
        fi
    
    - name: Deploy application services
      run: |
        echo "Deploying application services..."
        
        # Note: You'll need to add your application deployment files here
        # This is a placeholder for your actual application deployments
        
        echo "Checking for application deployment files..."
        if [ -d "deployments" ]; then
          echo "Found deployments directory, applying all deployments..."
          kubectl apply -f deployments/
        else
          echo "No deployments directory found. Please add your application deployment files."
        fi
        
        if [ -d "services" ]; then
          echo "Applying additional services..."
          find services/ -name "*.yaml" ! -name "mysql*" -exec kubectl apply -f {} \;
        fi
    
    - name: Apply Network Policies
      run: |
        echo "Applying network policies..."
        kubectl apply -f network-policies/namespace-default-deny.yaml
        kubectl apply -f network-policies/mysql-netpol.yaml
        
        echo "Verifying network policies..."
        kubectl get networkpolicies -n $NAMESPACE
    
    - name: Apply HPA (Horizontal Pod Autoscalers)
      run: |
        echo "Applying HPAs..."
        kubectl apply -f hpa/hpa.yaml
        
        echo "Waiting for HPAs to be ready..."
        sleep 30
        
        echo "Verifying HPAs..."
        kubectl get hpa -n $NAMESPACE
    
    - name: Apply Ingress
      run: |
        echo "Applying Ingress..."
        kubectl apply -f ingress/bedrock-chat-ingress.yaml
        
        echo "Verifying Ingress..."
        kubectl get ingress -n $NAMESPACE
        kubectl describe ingress bedrock-chat-ingress -n $NAMESPACE
    
    - name: Apply CronJobs
      run: |
        echo "Applying CronJobs..."
        # The backup cronjob was already applied with PVC, but let's make sure
        kubectl get cronjob -n $NAMESPACE
        
        echo "Verifying CronJob schedule..."
        kubectl describe cronjob/mysql-backup -n $NAMESPACE
    
    - name: Final verification
      run: |
        echo "=== DEPLOYMENT VERIFICATION ==="
        echo "Namespace:"
        kubectl get namespace $NAMESPACE
        
        echo -e "\nSecrets:"
        kubectl get secrets -n $NAMESPACE
        
        echo -e "\nConfigMaps:"
        kubectl get configmaps -n $NAMESPACE
        
        echo -e "\nPVCs:"
        kubectl get pvc -n $NAMESPACE
        
        echo -e "\nStatefulSets:"
        kubectl get statefulsets -n $NAMESPACE
        
        echo -e "\nServices:"
        kubectl get services -n $NAMESPACE
        
        echo -e "\nPods:"
        kubectl get pods -n $NAMESPACE -o wide
        
        echo -e "\nNetworkPolicies:"
        kubectl get networkpolicies -n $NAMESPACE
        
        echo -e "\nHPAs:"
        kubectl get hpa -n $NAMESPACE
        
        echo -e "\nIngress:"
        kubectl get ingress -n $NAMESPACE
        
        echo -e "\nCronJobs:"
        kubectl get cronjobs -n $NAMESPACE
    
    - name: Health checks
      run: |
        echo "=== HEALTH CHECKS ==="
        
        echo "Checking MySQL health..."
        MYSQL_POD=$(kubectl get pods -l app=mysql -n $NAMESPACE -o jsonpath='{.items[0].metadata.name}')
        if [ ! -z "$MYSQL_POD" ]; then
          kubectl exec -n $NAMESPACE $MYSQL_POD -- mysqladmin ping -u root -proot_password || echo "MySQL health check failed"
        fi
        
        echo "Checking pod status..."
        kubectl get pods -n $NAMESPACE | grep -E "(Running|Completed)" || echo "Some pods are not in Running/Completed state"
        
        echo "Checking for any failed pods..."
        FAILED_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Failed -o name)
        if [ ! -z "$FAILED_PODS" ]; then
          echo "Found failed pods:"
          echo "$FAILED_PODS"
          echo "Describing failed pods..."
          kubectl describe pods --field-selector=status.phase=Failed -n $NAMESPACE
        else
          echo "No failed pods found"
        fi
    
    - name: Cleanup on failure
      if: failure()
      run: |
        echo "=== DEPLOYMENT FAILED - GATHERING DEBUG INFO ==="
        
        echo "Pod logs for debugging..."
        kubectl get pods -n $NAMESPACE -o name | while read pod; do
          echo "=== Logs for $pod ==="
          kubectl logs $pod -n $NAMESPACE --tail=50 || echo "Could not get logs for $pod"
        done
        
        echo "Events in namespace:"
        kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp'
        
        echo "Describing problematic pods..."
        kubectl describe pods -n $NAMESPACE | grep -A 20 -B 5 "Warning\|Error\|Failed" || echo "No warning/error events found"
    
    - name: Deployment summary
      if: always()
      run: |
        echo "=== DEPLOYMENT SUMMARY ==="
        echo "Timestamp: $(date)"
        echo "Namespace: $NAMESPACE"
        echo "Cluster: $(kubectl config current-context)"
        
        TOTAL_PODS=$(kubectl get pods -n $NAMESPACE --no-headers | wc -l)
        RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --no-headers | grep Running | wc -l)
        
        echo "Total pods: $TOTAL_PODS"
        echo "Running pods: $RUNNING_PODS"
        
        if [ $TOTAL_PODS -eq $RUNNING_PODS ] && [ $TOTAL_PODS -gt 0 ]; then
          echo "✅ Deployment successful! All pods are running."
        else
          echo "⚠️  Deployment completed with issues. Check pod status above."
        fi
