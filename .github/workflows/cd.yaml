name: Deploy Bedrock Chat Multi-Repo
on:
  workflow_run:
    workflows: ["Setup Infra and Deploy GitHub Runner"]  # Replace with your exact Terraform workflow name
    types:
      - completed
    branches: [ main, master ]
  workflow_dispatch:  # Keep manual trigger option
jobs:
  deploy:
    runs-on: self-hosted
    # Only run if the Terraform workflow succeeded (skip if manually triggered)
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout main repo
      uses: actions/checkout@v4
      with:
        path: main-repo
    
    - name: Run setup script
      run: |
        echo "Running setup.sh from main repo root..."
        cd main-repo
        if [ -f "setup.sh" ]; then
          chmod +x setup.sh
          ./setup.sh
          echo "Setup script executed successfully"
        else
          echo "ERROR: setup.sh not found in main repo root"
          exit 1
        fi
    
    - name: Checkout front-end repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/front-end
        path: front-end
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout bedrock-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/bedrock-service
        path: bedrock-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout file-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/file-service
        path: file-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout api-gateway repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/api-gateway
        path: api-gateway
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Deploy Main Repo
      run: |
        echo "Deploying main repo Kubernetes manifests..."
        cd main-repo
        kubectl apply -f namespace.yaml
        kubectl apply -f secrets/
        kubectl apply -f configmaps/
        kubectl apply -f metrics-server-custom.yaml
        kubectl apply -f statefulsets/
        kubectl apply -f services/
        kubectl apply -f monitoring/
        kubectl apply -f network-policies/
        kubectl apply -f hpa/
        kubectl apply -f ingress/
    
    - name: Create AWS Secrets
      run: |
        echo "üîê Creating AWS secrets..."
        
        # Create AWS secrets using organization secrets
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Secret
        metadata:
          name: app-secrets
          namespace: bedrock-chat-v2
        type: Opaque
        stringData:
          AWS_ACCESS_KEY_ID: "${{ secrets.AWS_ACCESS_KEY_ID }}"
          AWS_SECRET_ACCESS_KEY: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          AWS_REGION: "us-east-1"
        EOF
        
        echo "‚úÖ AWS secrets created"
    
    - name: Deploy Front-End Service
      run: |
        echo "Deploying front-end Kubernetes manifests..."
        if [ -d "front-end/k8s" ]; then
          kubectl apply -f front-end/k8s/ --recursive
        else
          echo "No k8s folder found in front-end repo"
        fi
    
    - name: Deploy Bedrock Service
      run: |
        echo "Deploying bedrock-service Kubernetes manifests..."
        if [ -d "bedrock-service/k8s" ]; then
          kubectl apply -f bedrock-service/k8s/ --recursive
        else
          echo "No k8s folder found in bedrock-service repo"
        fi
    
    - name: Deploy File Service
      run: |
        echo "Deploying file-service Kubernetes manifests..."
        if [ -d "file-service/k8s" ]; then
          kubectl apply -f file-service/k8s/ --recursive
        else
          echo "No k8s folder found in file-service repo"
        fi
    
    - name: Deploy API Gateway
      run: |
        echo "Deploying api-gateway Kubernetes manifests..."
        if [ -d "api-gateway/k8s" ]; then
          kubectl apply -f api-gateway/k8s/ --recursive
        else
          echo "No k8s folder found in api-gateway repo"
        fi
    
    - name: Wait for Application to be Ready
      run: |
        echo "‚è≥ Waiting for all pods to be ready before running DAST..."
        kubectl wait --for=condition=ready pod -l app=frontend -n bedrock-chat-v2 --timeout=300s || true
        kubectl wait --for=condition=ready pod -l app=api-gateway -n bedrock-chat-v2 --timeout=300s || true
        kubectl wait --for=condition=ready pod -l app=bedrock-service -n bedrock-chat-v2 --timeout=300s || true
        kubectl wait --for=condition=ready pod -l app=file-service -n bedrock-chat-v2 --timeout=300s || true
        
        echo "üîç Checking pod status:"
        kubectl get pods -n bedrock-chat-v2
        
        # Wait additional time for ingress to be ready
        echo "‚è≥ Waiting for ingress to be ready..."
        sleep 60
    
    - name: Get Application URL
      id: get_url
      run: |
        # Get the ingress controller external IP or NodePort
        INGRESS_IP=""
        
        # Try to get LoadBalancer IP first
        INGRESS_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        if [ -z "$INGRESS_IP" ]; then
          # If no LoadBalancer, get NodePort
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          NODE_PORT=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}' 2>/dev/null || echo "80")
          INGRESS_IP="${NODE_IP}:${NODE_PORT}"
        fi
        
        if [ -z "$INGRESS_IP" ] || [ "$INGRESS_IP" = ":" ]; then
          # Fallback to localhost for self-hosted runner
          INGRESS_IP="localhost"
        fi
        
        APP_URL="http://${INGRESS_IP}"
        echo "APPLICATION_URL=${APP_URL}" >> $GITHUB_OUTPUT
        echo "üåê Application URL: ${APP_URL}"
    
    - name: Install OWASP ZAP
      run: |
        echo "üì¶ Installing OWASP ZAP..."
        
        # Install Java if not present
        sudo apt-get update -y
        sudo apt-get install -y default-jre wget unzip
        
        # Download and install ZAP
        cd /tmp
        wget -q https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_Linux.tar.gz
        tar -xzf ZAP_2_14_0_Linux.tar.gz
        sudo mv ZAP_2.14.0 /opt/zaproxy
        sudo ln -sf /opt/zaproxy/zap.sh /usr/local/bin/zap.sh
        
        echo "‚úÖ OWASP ZAP installed successfully"
    
    - name: Run DAST Scan with OWASP ZAP
      run: |
        echo "üîí Starting DAST security scan..."
        
        APP_URL="${{ steps.get_url.outputs.APPLICATION_URL }}"
        echo "Scanning URL: $APP_URL"
        
        # Create reports directory
        mkdir -p dast-reports
        
        # Test if application is accessible
        echo "üîç Testing application accessibility..."
        if curl -f -s --max-time 30 "$APP_URL" > /dev/null; then
          echo "‚úÖ Application is accessible"
        else
          echo "‚ö†Ô∏è Application may not be fully ready, but proceeding with scan..."
        fi
        
        # Run ZAP baseline scan (quick scan for common vulnerabilities)
        echo "üöÄ Running ZAP baseline scan..."
        /opt/zaproxy/zap.sh -cmd \
          -quickurl "$APP_URL" \
          -quickout dast-reports/zap-baseline-report.html \
          -quickprogress || echo "ZAP scan completed with findings"
        
        # Run ZAP spider + passive scan for more comprehensive testing
        echo "üï∑Ô∏è Running ZAP spider and passive scan..."
        /opt/zaproxy/zap.sh -cmd \
          -newsession \
          -spider "$APP_URL" \
          -pscanwait \
          -htmlreport dast-reports/zap-full-report.html \
          -exit || echo "ZAP full scan completed"
        
        echo "‚úÖ DAST scan completed"
    
    - name: Process DAST Results
      run: |
        echo "üìä Processing DAST scan results..."
        
        if [ -f "dast-reports/zap-baseline-report.html" ]; then
          echo "‚úÖ ZAP baseline report generated"
          
          # Extract basic statistics (this is a simple approach)
          if grep -q "High.*Risk" dast-reports/zap-baseline-report.html; then
            echo "üö® HIGH RISK vulnerabilities found!"
            HIGH_RISK_COUNT=$(grep -o "High.*Risk" dast-reports/zap-baseline-report.html | wc -l || echo "0")
            echo "High risk issues: $HIGH_RISK_COUNT"
          fi
          
          if grep -q "Medium.*Risk" dast-reports/zap-baseline-report.html; then
            echo "‚ö†Ô∏è MEDIUM RISK vulnerabilities found"
            MEDIUM_RISK_COUNT=$(grep -o "Medium.*Risk" dast-reports/zap-baseline-report.html | wc -l || echo "0")
            echo "Medium risk issues: $MEDIUM_RISK_COUNT"
          fi
          
          echo "üìÑ DAST report summary:"
          echo "- Baseline scan report: dast-reports/zap-baseline-report.html"
          if [ -f "dast-reports/zap-full-report.html" ]; then
            echo "- Full scan report: dast-reports/zap-full-report.html"
          fi
        else
          echo "‚ö†Ô∏è No DAST reports generated"
        fi
    
    - name: Upload DAST Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: dast-security-reports
        path: dast-reports/
        retention-days: 30
    
    - name: Final Status Check
      run: |
        echo "Deployment completed for all services!"
        echo "Current status:"
        kubectl get all -n bedrock-chat-v2
        
        echo "Checking pods status:"
        kubectl get pods -n bedrock-chat-v2 -o wide
        
        echo "Checking services:"
        kubectl get services -n bedrock-chat-v2
        
        echo "üîí DAST Security Scan Summary:"
        echo "- Security scan completed using OWASP ZAP"
        echo "- Reports uploaded as artifacts"
        echo "- Check the 'dast-security-reports' artifact for detailed findings"
        
        APP_URL="${{ steps.get_url.outputs.APPLICATION_URL }}"
        echo "üåê Application URL: $APP_URL"
