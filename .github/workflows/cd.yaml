name: Deploy Bedrock Chat Multi-Repo
on:
  workflow_run:
    workflows: ["Setup Infra and Deploy GitHub Runner"]  # Replace with your exact Terraform workflow name
    types:
      - completed
    branches: [ main, master ]
  workflow_dispatch:  # Keep manual trigger option
jobs:
  deploy:
    runs-on: self-hosted
    # Only run if the Terraform workflow succeeded (skip if manually triggered)
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout main repo
      uses: actions/checkout@v4
      with:
        path: main-repo
    
    - name: Run setup script
      run: |
        echo "Running setup.sh from main repo root..."
        cd main-repo
        if [ -f "setup.sh" ]; then
          chmod +x setup.sh
          ./setup.sh
          echo "Setup script executed successfully"
        else
          echo "ERROR: setup.sh not found in main repo root"
          exit 1
        fi
    
    - name: Checkout front-end repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/front-end
        path: front-end
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout bedrock-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/bedrock-service
        path: bedrock-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout file-service repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/file-service
        path: file-service
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Checkout api-gateway repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/api-gateway
        path: api-gateway
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Wait for Ingress Controller Ready
      run: |
        echo "‚è≥ Ensuring NGINX ingress controller is ready..."
        
        # Wait for ingress controller deployment to be ready
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=300s || echo "‚ö†Ô∏è Ingress controller wait timeout, continuing..."
        
        # Wait for admission webhook to be available
        echo "‚è≥ Waiting for ingress admission webhook..."
        for i in {1..20}; do
          if kubectl get validatingwebhookconfiguration ingress-nginx-admission >/dev/null 2>&1; then
            echo "‚úÖ Admission webhook is ready"
            break
          fi
          echo "Attempt $i/20: Waiting for admission webhook... (10s)"
          sleep 10
        done
        
        echo "‚úÖ Ingress controller readiness check completed"
    
    - name: Deploy Main Repo
      run: |
        echo "Deploying main repo Kubernetes manifests..."
        cd main-repo
        kubectl apply -f namespace.yaml
        kubectl apply -f secrets/
        kubectl apply -f configmaps/
        kubectl apply -f metrics-server-custom.yaml
        kubectl apply -f statefulsets/
        kubectl apply -f services/
        kubectl apply -f monitoring/
        kubectl apply -f network-policies/
        kubectl apply -f hpa/
        
        # Deploy ingress with retry mechanism
        echo "üåê Deploying ingress with retry logic..."
        for attempt in {1..3}; do
          echo "Ingress deployment attempt $attempt/3"
          if kubectl apply -f ingress/; then
            echo "‚úÖ Ingress deployed successfully"
            break
          else
            echo "‚ö†Ô∏è Ingress deployment failed, waiting 30s before retry..."
            sleep 30
          fi
        done
    
    - name: Create AWS Secrets
      run: |
        echo "üîê Creating AWS secrets..."
        
        # Create AWS secrets using organization secrets
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Secret
        metadata:
          name: app-secrets
          namespace: bedrock-chat-v2
        type: Opaque
        stringData:
          AWS_ACCESS_KEY_ID: "${{ secrets.AWS_ACCESS_KEY_ID }}"
          AWS_SECRET_ACCESS_KEY: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          AWS_REGION: "us-east-1"
        EOF
        
        echo "‚úÖ AWS secrets created"
    
    - name: Deploy Front-End Service
      run: |
        echo "Deploying front-end Kubernetes manifests..."
        if [ -d "front-end/k8s" ]; then
          kubectl apply -f front-end/k8s/ --recursive
        else
          echo "No k8s folder found in front-end repo"
        fi
    
    - name: Deploy Bedrock Service
      run: |
        echo "Deploying bedrock-service Kubernetes manifests..."
        if [ -d "bedrock-service/k8s" ]; then
          kubectl apply -f bedrock-service/k8s/ --recursive
        else
          echo "No k8s folder found in bedrock-service repo"
        fi
    
    - name: Deploy File Service
      run: |
        echo "Deploying file-service Kubernetes manifests..."
        if [ -d "file-service/k8s" ]; then
          kubectl apply -f file-service/k8s/ --recursive
        else
          echo "No k8s folder found in file-service repo"
        fi
    
    - name: Deploy API Gateway
      run: |
        echo "Deploying api-gateway Kubernetes manifests..."
        if [ -d "api-gateway/k8s" ]; then
          kubectl apply -f api-gateway/k8s/ --recursive
        else
          echo "No k8s folder found in api-gateway repo"
        fi
    
    - name: Wait for Application Components
      run: |
        echo "‚è≥ Waiting for application components to be ready..."
        
        # Wait for MySQL first (foundational service)
        echo "üóÑÔ∏è Waiting for MySQL..."
        kubectl wait --for=condition=ready pod -l app=mysql -n bedrock-chat-v2 --timeout=600s || echo "‚ö†Ô∏è MySQL timeout, continuing..."
        
        # Wait for application services
        echo "üîß Waiting for application services..."
        kubectl wait --for=condition=ready pod -l app=frontend -n bedrock-chat-v2 --timeout=300s || echo "‚ö†Ô∏è Frontend timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=api-gateway -n bedrock-chat-v2 --timeout=300s || echo "‚ö†Ô∏è API Gateway timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=bedrock-service -n bedrock-chat-v2 --timeout=300s || echo "‚ö†Ô∏è Bedrock Service timeout, continuing..."
        kubectl wait --for=condition=ready pod -l app=file-service -n bedrock-chat-v2 --timeout=300s || echo "‚ö†Ô∏è File Service timeout, continuing..."
        
        echo "üìä Current pod status:"
        kubectl get pods -n bedrock-chat-v2
        
        # Additional stabilization time
        echo "‚è≥ Additional stabilization time (60s)..."
        sleep 60
    
    - name: Determine Application URL
      id: app_url
      run: |
        echo "üåê Determining application access URL..."
        
        # Initialize variables
        APP_URL=""
        ACCESS_METHOD=""
        
        # Method 1: Try ingress with LoadBalancer
        INGRESS_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -n "$INGRESS_IP" ] && [ "$INGRESS_IP" != "null" ]; then
          APP_URL="http://$INGRESS_IP"
          ACCESS_METHOD="ingress-loadbalancer"
        fi
        
        # Method 2: Try ingress with NodePort
        if [ -z "$APP_URL" ]; then
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null)
          fi
          NODE_PORT=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}' 2>/dev/null)
          
          if [ -n "$NODE_IP" ] && [ -n "$NODE_PORT" ]; then
            APP_URL="http://$NODE_IP:$NODE_PORT"
            ACCESS_METHOD="ingress-nodeport"
          fi
        fi
        
        # Method 3: Direct service access
        if [ -z "$APP_URL" ]; then
          # Check if frontend service has NodePort
          FRONTEND_NODEPORT=$(kubectl get svc frontend -n bedrock-chat-v2 -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          if [ -n "$FRONTEND_NODEPORT" ] && [ -n "$NODE_IP" ]; then
            APP_URL="http://$NODE_IP:$FRONTEND_NODEPORT"
            ACCESS_METHOD="direct-service"
          fi
        fi
        
        # Method 4: Localhost fallback
        if [ -z "$APP_URL" ]; then
          APP_URL="http://localhost:80"
          ACCESS_METHOD="localhost-fallback"
        fi
        
        echo "APPLICATION_URL=$APP_URL" >> $GITHUB_OUTPUT
        echo "ACCESS_METHOD=$ACCESS_METHOD" >> $GITHUB_OUTPUT
        echo "üåê Application URL: $APP_URL (method: $ACCESS_METHOD)"
        
        # Test URL accessibility
        echo "üîç Testing URL accessibility..."
        if timeout 10 curl -f -s "$APP_URL" >/dev/null 2>&1; then
          echo "‚úÖ URL is accessible"
          echo "URL_ACCESSIBLE=true" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è URL not immediately accessible (will retry during DAST)"
          echo "URL_ACCESSIBLE=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Setup DAST Environment
      run: |
        echo "üõ†Ô∏è Setting up DAST environment..."
        
        # Ensure Docker is running and accessible
        sudo systemctl start docker
        sudo usermod -aG docker $USER || true
        
        # Pull ZAP image in advance
        echo "üì¶ Pulling OWASP ZAP Docker image..."
        sudo docker pull ghcr.io/zaproxy/zaproxy:stable || {
          echo "‚ö†Ô∏è Failed to pull ZAP image, trying alternative..."
          sudo docker pull owasp/zap2docker-stable || echo "‚ö†Ô∏è Alternative image also failed"
        }
        
        # Create reports directory
        mkdir -p dast-reports
        chmod 777 dast-reports
        
        echo "‚úÖ DAST environment setup completed"
    
    - name: Run DAST Security Scan
      run: |
        echo "üîí Starting DAST security scan..."
        
        APP_URL="${{ steps.app_url.outputs.APPLICATION_URL }}"
        ACCESS_METHOD="${{ steps.app_url.outputs.ACCESS_METHOD }}"
        URL_ACCESSIBLE="${{ steps.app_url.outputs.URL_ACCESSIBLE }}"
        
        echo "üìã Scan Configuration:"
        echo "  Target URL: $APP_URL"
        echo "  Access Method: $ACCESS_METHOD"
        echo "  Initially Accessible: $URL_ACCESSIBLE"
        
        # Extended accessibility test with retry
        echo "üîç Extended URL accessibility test..."
        RETRIES=8
        WAIT_TIME=30
        FINAL_ACCESSIBLE=false
        
        for i in $(seq 1 $RETRIES); do
          echo "  Attempt $i/$RETRIES: Testing $APP_URL"
          if timeout 15 curl -f -s -L "$APP_URL" >/dev/null 2>&1; then
            echo "  ‚úÖ URL accessible on attempt $i"
            FINAL_ACCESSIBLE=true
            break
          else
            echo "  ‚è≥ Not accessible, waiting ${WAIT_TIME}s..."
            sleep $WAIT_TIME
          fi
        done
        
        # Create baseline scan summary
        cat > dast-reports/scan-info.txt << EOF
DAST Security Scan Information
==============================
Scan Date: $(date)
Target URL: $APP_URL
Access Method: $ACCESS_METHOD
Final Accessibility: $FINAL_ACCESSIBLE
Scanner: OWASP ZAP

Scan Results:
EOF
        
        # Run ZAP baseline scan
        echo "üöÄ Running OWASP ZAP baseline scan..."
        ZAP_EXIT_CODE=0
        
        sudo docker run --rm \
          -v $(pwd)/dast-reports:/zap/wrk/:rw \
          -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
          -t "$APP_URL" \
          -r baseline-report.html \
          -w baseline-report.md \
          -J baseline-report.json \
          -d \
          || ZAP_EXIT_CODE=$?
        
        echo "ZAP baseline scan exit code: $ZAP_EXIT_CODE"
        echo "ZAP Exit Code: $ZAP_EXIT_CODE" >> dast-reports/scan-info.txt
        
        # If baseline fails, try a simple API scan
        if [ ! -f "dast-reports/baseline-report.html" ] && [ "$FINAL_ACCESSIBLE" = "true" ]; then
          echo "üîÑ Baseline scan failed, trying API scan..."
          sudo docker run --rm \
            -v $(pwd)/dast-reports:/zap/wrk/:rw \
            -t ghcr.io/zaproxy/zaproxy:stable zap-api-scan.py \
            -t "$APP_URL" \
            -r api-scan-report.html \
            -w api-scan-report.md \
            || echo "API scan also completed with warnings"
        fi
        
        # Create fallback report if no scans succeeded
        if [ ! -f "dast-reports/baseline-report.html" ] && [ ! -f "dast-reports/api-scan-report.html" ]; then
          echo "üìù Creating fallback security report..."
          cat > dast-reports/fallback-report.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>DAST Scan Report</title></head>
<body>
<h1>DAST Security Scan Report</h1>
<h2>Scan Status</h2>
<p><strong>Status:</strong> Scan attempted but application may not have been fully accessible.</p>
<p><strong>Recommendation:</strong> Verify application deployment and rerun security scan.</p>
<h2>Next Steps</h2>
<ul>
<li>Check application logs for deployment issues</li>
<li>Verify ingress configuration</li>
<li>Manually test application accessibility</li>
<li>Re-run DAST scan when application is confirmed accessible</li>
</ul>
</body>
</html>
EOF
          echo "Fallback report created" >> dast-reports/scan-info.txt
        fi
        
        echo "‚úÖ DAST scan process completed"
    
    - name: Process DAST Results
      run: |
        echo "üìä Processing DAST scan results..."
        
        # List all generated files
        echo "üìÅ Generated files:"
        ls -la dast-reports/ || echo "No files generated"
        
        # Process different report types
        REPORTS_FOUND=0
        
        # Check for baseline report
        if [ -f "dast-reports/baseline-report.html" ]; then
          echo "‚úÖ Baseline HTML report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        if [ -f "dast-reports/baseline-report.md" ]; then
          echo "‚úÖ Baseline Markdown report found"
          echo "üìã Baseline scan summary:"
          head -20 "dast-reports/baseline-report.md" || echo "Could not read markdown report"
        fi
        
        # Check for API scan report
        if [ -f "dast-reports/api-scan-report.html" ]; then
          echo "‚úÖ API scan HTML report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        # Check for fallback report
        if [ -f "dast-reports/fallback-report.html" ]; then
          echo "‚ÑπÔ∏è Fallback report found"
          REPORTS_FOUND=$((REPORTS_FOUND + 1))
        fi
        
        # Security analysis
        echo "üîç Security analysis:"
        if [ $REPORTS_FOUND -gt 0 ]; then
          # Look for high-risk findings
          if grep -i "high\|critical" dast-reports/*.html dast-reports/*.md 2>/dev/null | head -5; then
            echo "üö® Potential high-risk security issues detected!"
            echo "üìÑ Review the detailed reports for more information."
          else
            echo "‚úÖ No critical security issues detected in scan."
          fi
        else
          echo "‚ö†Ô∏è No security reports generated - application may not have been accessible."
        fi
        
        # Update scan info with results
        echo "" >> dast-reports/scan-info.txt
        echo "Reports Generated: $REPORTS_FOUND" >> dast-reports/scan-info.txt
        echo "Scan Completed: $(date)" >> dast-reports/scan-info.txt
    
    - name: Upload DAST Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: dast-security-reports-${{ github.run_number }}
        path: dast-reports/
        retention-days: 30
    
    - name: Final Status Check
      run: |
        echo "üéâ Deployment completed for all services!"
        
        echo "üìä Current status:"
        kubectl get all -n bedrock-chat-v2
        
        echo "üîç Checking pods status:"
        kubectl get pods -n bedrock-chat-v2 -o wide
        
        echo "üåê Checking services:"
        kubectl get services -n bedrock-chat-v2
        
        echo "üîí DAST Security Scan Summary:"
        echo "================================"
        if [ -f "dast-reports/scan-info.txt" ]; then
          cat dast-reports/scan-info.txt
        else
          echo "DAST scan info not available"
        fi
        
        echo ""
        echo "‚úÖ Pipeline completed successfully!"
        echo "üìÑ Security reports uploaded as artifacts"
        echo "üåê Application URL: ${{ steps.app_url.outputs.APPLICATION_URL }}"
